---
title: 在编程中为所欲为[圣诞版]
tags:
- 程序设计
---
众所周知，在Java中final String中的值是一成不变的。大家都知道String的+(拼接)运算会丢弃内存引用并在内存中重新开拓地址，事实上也确实如此。但final的变量真的是一成不变的吗？谨以此文打开程序员思路，跳出定式思维，希望本文会给你的程序员生涯带来新的思考。

# 一个简单的例子

这个例子很久远，早有前辈做过，但并不是所有的程序员都接触过。通常喜欢“猎奇”的程序员对此不会陌生。

```java

import java.lang.reflect.Field;

public class ChangeFinalString {

	public static void main(String[] args) throws Exception {
		final String s = "12345: caiyongji";
		System.out.println(s);
		System.out.println("hashcode: " + s.hashCode());
		Field f = String.class.getDeclaredField("value");
		f.setAccessible(true);
		char[] value = (char[]) f.get(s);
		value[0] = (char) 20851;
		value[1] = (char) 27880;
		value[2] = (char) 20844;
		value[3] = (char) 20247;
		value[4] = (char) 21495;
		System.out.println(s);
		System.out.println("hashcode: " + s.hashCode());
	}
}

```

例子中，通过final初始化一个String，然后反射获取String类中名为value的Field，并重新赋值value。执行后，你会发现String的hashcode值没有变，String的值却变了。另外，你还会发现这几行简单代码的彩蛋。

# 得出结论

看！是不是觉得常规可以被打破，只要有足够的技巧就可以在编程中为所欲为？也许有些严谨的程序员会指出hashcode方法的实现依赖于JVM，并不能直接反映内存的情况。说实话，你甚至不需要记住本文的例子，我只是想打破你固有的思维模式。

**然而，上面的并不是我想说的真正结论。**

下面，才是“**圣诞版**”真正的意义。

也许有些人会觉得收获颇丰，我又掌握了一个面试问题的答案。没错，甚至像阿里、百度这样的国内巨头企业中，有一些面试官（注意是**有一些**），确实会问一些"final变量是不可变"这样的silly question. 他们钻研一门语言甚至知道所有具体实现的细节，甚至语言的bug。 但换个角度，在如此钻研的同时，你是否考虑了你的时间成本、女朋友以及后代？！

# 接口论

作为一个程序员，你是业务逻辑和代码实现的接口。没人在乎你怎么实现的业务，只在乎你的代码是否高效、准确、易用、易拓展（具体讲，比如多少ms返回结果，参数结构是否简单，是否容易添加新功能）。同理，你使用Java作为你实现业务逻辑的工具，你更可以选择Python、Node.js、Kotlin甚至Linux shell脚本，那么你是否要理解Java语言的所有实现？正如我在《如何成为10倍速的程序员》中所说的不要记忆。

我是在号召大家不求甚解吗？
是的。

# 反设计
如果把编程手段当成一种工具，无外乎语言、文档、框架，这些都可以当成是工具的一部分。不要试图用锤子打开螺丝钉，虽然你确实可以做到。但这是反设计的。就像这个例子一样，你可以通过reflect改变final，但说白了，这种技巧并没有什么用，它会给你带来很多麻烦，比如在拓展时、在java版本升级时考虑兼容性。

所以，在使用一种“工具”时，要尽量按照工具制造者的思维模式进行使用，所有这些所谓的“技巧”都是在反设计。

----------

最后，专注、严谨、逻辑清晰是一个程序员的品质，但在技术迭代如此迅速的大背景下，**在代码中追求极致是一个人类无法做到的**（如果用掌握技巧的**多**来衡量的话，你永远无法掌握所有技巧，并且，在技术迭代过程中，你原本掌握的技巧也在逐步淘汰。），别忘了你生活中的朋友、家人和你的爱好。

过完圣诞就是新的一年，祝所有的程序员朋友圣诞快乐（本文写于平安夜），同时在新的一年里开启程序员新的、不一样的人生。
